1. Features of Python.

Answer --> 
    1. Easy to Learn and Use
    2. Open-Source and Free
    3. Interpreted Language
    4. Cross-Platform
    5. Object-Oriented and Procedural
    6. Large Standard Library
    7. Dynamically Typed
    8. High-Level Language
    9. Integration Friendly



____________________________________________________________________________________________________________________


2. Data types in Python.
Answer -->
    Data type is a classification of like which type of value variable can hold.
    In python there are various type of data type available
 

    Numeric	            int, float, complex	            10, 3.14, 2+3j
    Text	            str	                            "Python"
    Sequence	        list, tuple, range	            [1, 2, 3], (4, 5), range(5)
    Set	                set, frozenset	                {1, 2, 3}, frozenset([4, 5])
    Mapping	            dict	                        {"key": "value"}
    Boolean	            bool	                        True, False
    Binary	            bytes, bytearray, memoryview	b"data", bytearray(5)
    None	            NoneType                       	None



____________________________________________________________________________________________________________________



3. Set and Frozenset in Python ?
Answer -->

    1. What is a Set?

        A set is a collection of unique and unordered elements in Python.

        Key Points:
        Mutable: You can add or remove elements.
        No Duplicates: Automatically removes duplicate elements.
        Unordered: No indexing or slicing (e.g., no set[0]).
        Optimized for Membership Testing: Checking if an item exists in a set is fast.

        Example --->

            my_set = {1, 2, 3, 4, 4}  # Duplicates are removed
            print(my_set)  # Output: {1, 2, 3, 4}

            my_set.add(5)  # Add an element
            my_set.remove(2)  # Remove an element
            print(my_set)  # Output: {1, 3, 4, 5}



    2. What is a Frozenset?
        A frozenset is an immutable version of a set. Once created, it cannot be changed (no adding or removing elements).

        Key Points:
        Immutable: Cannot be modified after creation.
        Hashable: Can be used as a key in a dictionary or an element in another set.
        Unordered: Like a set, it does not support indexing or slicing.

        Example -->

        my_frozenset = frozenset([1, 2, 3, 4])
        print(my_frozenset)  # Output: frozenset({1, 2, 3, 4})

        # Immutable, so these operations are not allowed:
        # my_frozenset.add(5) -> Raises AttributeError
        # my_frozenset.remove(2) -> Raises AttributeError


    3. Differences Between Set and Frozenset ?

        Feature	                        Set	                            Frozenset
        Mutability	                    Mutable	                        Immutable
        Duplicates Allowed	             No	                                No
        Hashable	                     No	            Yes (can be used as a dictionary key or set element)
        Modifications	    Supports adding/removing elements	Does not allow modifications
        Usage	                    Dynamic collections	Fixed collections (e.g., when elements shouldn't change)


_____________________________________________________________________________________________________________________


4. Tuple and list in Python.
Answer -->

        List --> List is a collection of iteams. list store different type of data like int , float , str , bool etc.
                 list is a mutable means once we define so we can change the structure we can add something we can delete something and also we can add something.list is a ordered collection. and list is define using square bracets [].

        Tuple --> Tuple is a collection of iteam. tuple is also store different type of data like int , 
                float ,str , bool etc. tuple is immutable means once we define tuple so we can not change the structure means we can not add , delete , update and etc. tuple is also ordered collection. and its defined using paranthesis ().



    Differences between List and Tuple
    ___________________________________

                        List                                               Tuple
        1.  List is a Mutable. means once we defined            Tuple is a Immutable means once we defined so we can
            so we can change the structure we can               not change the structure we can not update ,delete,
            add , delete , update list element.                 and add.

        2. List is defined using square brackets[].             Tuple is defined using parentheses ().

        3. List is Slow.                                        Tuple is Fast    

        4. List consume more memory Because it is               Tuple Consume less memory Because it is a Fixed
           Dynamic collection.                                  collection.

        5. List can store any type of data.                     Tuple can also store any type of data.

        6. Lists are not hashable                               Tuples are hashable (can be used as dictionary 
           (cannot be used as dictionary keys).	                keys if they contain only hashable objects).
           



_____________________________________________________________________________________________________________________

5. Generators and iterators ?
Answer-->
________

        Iterators --> 
        __________
        An iterator is a powerful concept in Python that helps you to access the elements of a collection one at a time, But iterator store whole collection in a memory. so it comsume more memory. but whenever we working of large data set and we want to access one value at a time so we can use iterator

        It implements two special methods:

        1. __iter__(): This method initializes the iterator and returns the iterator object itself.
        2. __next__(): This method returns the next element in the collection. When there are no more elements to   iterate over, it raises a StopIteration exception.



        Example -->

        l = [1,2,3,4,5,6,7,8,9,10]

        it = iter(l)

        print(next(it))
        print(next(it))
        print(next(it))
        print(next(it))
        print(next(it))
        print(next(it))
        print(next(it))
        print(next(it))
        print(next(it))
        print(next(it))
        print(next(it))  # Give stopIteration error



        Generator --->
        ___________

        A generator in Python is a special type of iterator that allows you to iterate over a sequence of values, but unlike a normal iterator, it doesn't store the entire sequence in memory at once. Instead, a generator produces each value on the fly (lazily) when requested, making it more memory-efficient, especially when working with large data sets or streams of data.

        
        Defining a Generator in Python
        ______________________________

        A generator is defined using a function, but instead of using return, it uses yield. When yield is used, the function becomes a generator.


        Example ->
        _________

        # A generator function that yields numbers from 1 to 5
        def my_generator():
            for i in range(1, 6):
                yield i  # Yielding one value at a time

        # Create a generator object
        gen = my_generator()

        # Access the values one by one using next()
        print(next(gen))  # Output: 1
        print(next(gen))  # Output: 2
        print(next(gen))  # Output: 3
        print(next(gen))  # Output: 4
        print(next(gen))  # Output: 5



_____________________________________________________________________________________________________________________


6. iter() and next() in Python.
Answer ->
________

    1. iter() Function:
    ___________________
    The iter() function is used to convert an iterable (like a list, tuple, or string) into an iterator and if you print the iterator so its return the iterator objects.


    2. next() Function:
    ___________________
    The next() function is used to get the next item from the iterator, one at a time.

    How next() works:
    Each time you call next(), it returns the next item in the sequence.
    If the iterator is exhausted (all items have been returned), next() raises a StopIteration exception.




____________________________________________________________________________________________________________________

7. Multithreading  in Python.
Answer -->
_______

Multithreading -->
______________

Multithreading is a technique where a program can perform multiple tasks At the same time by dividing the work into smaller chunks called "threads". Each thread runs independently, so your program can do more things at the same time.

In Python , we can use threding module to implements multithreading


Why Use Multithreading?
_______________________

1. Concurrency: 
    Allows multiple tasks to run at the same time, improving the responsiveness of applications.
    Example: Handling user input while performing background computations.

2. Efficient I/O Operations: 
    Useful for tasks like file reading, database queries, or network requests where threads can perform other operations while waiting for I/O to complete.


Basic Multithreading Example -
_____________________________
import threading
import time

def print_numbers():
    for i in range(5):
        print(f"Thread 1: {i}")
        time.sleep(1)

def print_letters():
    for ch in 'abcde':
        print(f"Thread 2: {ch}")
        time.sleep(1)

# Create threads
thread1 = threading.Thread(target=print_numbers)
thread2 = threading.Thread(target=print_letters)

# Start threads
thread1.start()
thread2.start()

# Wait for threads to complete
thread1.join()
thread2.join()

print("All threadsj have completed.")



____________________________________________________________________________________________________________________



8. What is Pickling and unpickling in Python ?
Answer => pickling and unpickling is a process in python to serialize and deserialize python objects.


Pickling -> Pickling is a process to convert python object like ( list,dictionary). into the byte stream 
_________  means binary format. This byte stream can be stored in a file or transmitted over a network.



Example of Pickling ->
____________________
import pickle

# Data to pickle
data = {"name": "Alice", "age": 25, "skills": ["Python", "Machine Learning"]}

# Writing to a file
with open("data.pkl", "wb") as file:
    pickle.dump(data, file)

print("Data has been pickled and saved to 'data.pkl'.")





Unpickling -> Unpickling is a reverse process of pickling it convert the byte stream into the python objects 
-----------   It reads the binary data and recreates the object in memory.




Example of Unpickling ->
----------------------

import pickle

with open("data.pkl", "rb") as file:
    loaded_data = pickle.load(file)

print("Unpickled data:", loaded_data)




Why we use Pickling and unpickling ->
-----------------------------------
1. Data persistence: Save program data to a file for later use.
2. Data sharing: Share Python objects between programs or processes.
3. Complex data handling: Serialize Python-specific data types (e.g., custom classes) that JSON can't handle.
4. Performance: Easier and faster for Python-only projects.



_____________________________________________________________________________________________________________________




9. Currying in Python ?
Answer ->

Curring is a technique in the functional programming. Where a function that takes multiple arguments is converted into a sequence of functions, each function taking one argument.

In simple terms, currying allows us to break down a function that takes several parameters into multiple smaller functions, each accepting a single argument.




Why We Use Currying:
____________________
1. Reusability: We can partially apply a function by fixing some arguments and passing the remaining ones later.

2. Cleaner Code: Currying helps break down the code into smaller, modular functions, making the code more readable and maintainable.

3. Flexibility: Currying makes it easy to create new functions by applying some arguments first and using them later for different contexts.



Example of curring :
_______________________

def multiply(x):
    def multiply_by_y(y):
        def multiply_by_z(z):
            return x * y * z
        return multiply_by_z
    return multiply_by_y

# Pehle ek argument fix karte hain
partial_function = multiply(2)

# Baad mein baaki arguments pass karenge
result = partial_function(3)(4)  # 2 * 3 * 4 = 24
print(result)  # Output: 24




_____________________________________________________________________________________________________________________


10. Explain the concept of variable scoping in Python and provide examples of how global and local variables 
    are accessed within different scopes.

Answer ->

Scope is the region or area in the program where a variable is defined and determines where that variable can be accessed or modified.

Python follows a specific set of rules to look up and assign values to variables depending on where they are declared. This is  established by the LEGB rule:


1. Local Scope ->A variable is in the local scope if it is defined inside a function. It can only be accessed 
                    within that function.

    Example -> 
        def greet():
        message = "Hello, World!"  # Local variable
        print(message)

        greet()
        # print(message)  # Error! message is local to greet() function




2. Global Scope
A variable is in the global scope if it is defined outside of any function. It can be accessed both inside and outside functions.

Example ->
            x = 10  # Global variable

            def print_x():
                print(x)  # Accessing the global variable 'x'

            print_x()  # Prints 10
            print(x)   # Also prints 10 outside the function




3.Enclosing Scope (Nested Functions)
A variable in an enclosing scope refers to a variable that is defined in an outer (enclosing) function and can be accessed by an inner (nested) function.

Example ->
            def outer_function():
                outer_var = "I'm in the outer function"  # Variable in outer function
                
                def inner_function():
                    print(outer_var)  # Accessing variable from outer function
                
                inner_function()

            outer_function()



4. Built-in Scope
Python provides a set of built-in functions and objects, like print(), len(), etc., which are always accessible and available globally.


Example ->
print(len("Hello"))






_____________________________________________________________________________________________________________________


11. Shellow Copy and Deep Copy ?
Answer -> 


Whenever we work with mutable objects and want to create a copy, we have two types of copies available: shallow copy and deep copy.


1. Shellow Copy => 

A shallow copy creates a new object and copies the references of the nested objects instead of duplicating them. If you update a nested object in the copied object, the changes will also reflect in the original object because both share the same reference to the nested object.


Example =>

        import copy

        original = [1, 2, [3, 4]]  # Original list with a nested list
        shallow_copy = copy.copy(original)  # Create a shallow copy

        # Modify the nested object in the copied list
        shallow_copy[2][0] = 99

        print("Original:", original)  # Output: [1, 2, [99, 4]]
        print("Shallow Copy:", shallow_copy)  # Output: [1, 2, [99, 4]]


        We can also use copy function 
        Example =>

        original = {1, 2, 3}
        shallow_copy = original.copy()

        print("Original:", original)
        print("Shallow Copy:", shallow_copy)



2. Deep Copy =>
  
  A deep copy creates a completely independent copy of an object. Unlike a shallow copy, a deep copy does not share references to nested objects between the original and the copy. If you make changes to the nested objects in the copy, it will not affect the original object.


Example =>


            import copy

            l = [10,20,30,40,50,[1,2,3,4]]

            deep_copy_example = copy.deepcopy(l)

            # print(deep_copy_example)

            deep_copy_example[5][1] = 20


            print("origin :- ",l)
            print("Copy :- ",deep_copy_example)




_____________________________________________________________________________________________________________________


12. What is GIL (Global Interpreter Lock) ?
Answer =>

GIL stands for Global Interpreter Lock it is a mechanism that ensure that only one task executing at a time.
This means that even if you have a multiple thread in your program. and only one thread  executing at a time.



Why GIL exist in python
_______________________
Memory management: 

The GIL helps to manage memory safely in Python, especially when there are multiple threads running. Without the GIL, threads could try to access and modify the same piece of memory simultaneously, causing race conditions and other bugs.



How Does GIL Affect Multithreading?
___________________________________
1. Single-threaded performance (No problem with GIL)
In a single-threaded program, the GIL is not an issue because there’s only one thread running. The program will work as expected, and it can take full advantage of the CPU core it’s running on.

2. Multithreaded programs (GIL slows things down)
In a multithreaded program (where you have more than one thread running), the GIL limits performance because it only allows one thread to run Python code at a time. So even if you have a multi-core processor, Python threads won't run in parallel on those cores. Instead, they take turns running, which can result in less efficient performance for CPU-heavy tasks.






_____________________________________________________________________________________________________________________


13. What is the purpose of the @property decorator in Python?
Answer =>


The @property decorator in Python is a way to define a getter method that can be accessed like an attribute. In other words, it allows a method to be called without parentheses (like an attribute), but still perform some logic or computation behind the scenes.


Example ->

class Circle:
    def __init__(self, radius):
        self._radius = radius  # Private attribute

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative!")
        self._radius = value

circle = Circle(5)
print(circle.radius)  # Output: 5
circle.radius = 10    # Updates radius to 10
print(circle.radius)  # Output: 10
circle.radius = -1    # Raises ValueError




_____________________________________________________________________________________________________________________




14. How does Python handle exceptions? Explain how you can handle exceptions in Python.
Answer =>


So in python the exception handling is the process its protect our application from the runtime error.


i give two senerio
suppose if you are working on a project and during excution any error occurs in your program so you can fix this error easily
but the second senerio suppose you have deployed you'r application and now some errror occurs in your application so it is posible error can crash your application
so for this case we can use exception handling 

where we define try , except and finally and else block

in main functionality i know some error occures in future so i will defined the main logic inside the try block and if try block occurs any errror so my except block will excute>



Example =>



try:
    # Main functionality that might raise an error
    result = some_function()
except SomeSpecificError:
    # Handle the error if it occurs
    print("An error occurred!")
else:
    # Runs if no error occurs
    print("Operation successful!")
finally:
    # Always runs, no matter what
    print("Cleanup tasks done.")





_____________________________________________________________________________________________________________________


15. What is a metaclass in Python and how does it differ from regular classes?
Answer =>

Metaclass is a special type of a class in python. its control the process of creating class. Whenever you create a new class so python internally it is use metaclass for creting a class.


Example =>

# Apna ek metaclass banate hain
class MyMeta(type):
    def __new__(cls, name, bases, dct):
        print(f"Class {name} create ki ja rahi hai.")
        return super().__new__(cls, name, bases, dct)

# Ab hum ek class banayenge jisme yeh metaclass use hoga
class MyClass(metaclass=MyMeta):
    pass

# Jab yeh run hoga, output yeh hoga:
# Class MyClass create ki ja rahi hai.


_____________________________________________________________________________________________________________________



16. What is polymorphism in object-oriented programming, and how is it implemented in Python?
Answer =>


The polymorphism is a core concept of object oriented programming. polymorphism means "Many form"
You can use the same function , operation and method in different ways depending on a objects or a data type.

One technique example is like + operator because the + operator add two integer and the + operator also concetention
of two string so the  name of operator perform different operation according to objects and data type.



Example of polymorphism =>

class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

# Using the same method
dog = Dog()
cat = Cat()

print(dog.speak())  # Output: Woof!
print(cat.speak())  # Output: Meow!






1. Method Overriding => Method overrinding is the process when a child class provides its own implementation of 
                        a method that is already defined in the parent class.
                        It is used in a inheritance.


Example =>

class Parent:
    def greet(self):
        print("Hello from Parent!")

class Child(Parent):
    def greet(self):  # Overriding the greet method
        print("Hello from Child!")

# Example of overriding
obj = Child()
obj.greet()  # Output: Hello from Child!



How we can solve this problem =>
___________________________________

class A:
    def getdata(self):
        print("Parent class Info")
        
        
class B(A):
    def getdata(self):
        # A.getdata(self)
        # super().getdata()
        print("Child class info")
        
        
obj = B()
obj.getdata()





2 Method Overloading => Method Overloading is the process where we define multiple method with the same name but
_______________________  different number of parameters or different type of parameters.

In python method Overloading is not posible directly - so we can use a different way to implement method Overloading
in python like using -

1. Using variable length arguments
Example =>

class Calculator:
    def add(self, *args):
        return sum(args)

# Example Usage
calc = Calculator()
print(calc.add(10))              # 10
print(calc.add(10, 20))          # 30
print(calc.add(10, 20, 30, 40))  # 100




2. using multipledispatch
Example =>

from multipledispatch import dispatch

# Define overloaded methods
@dispatch(int, int)
def add(a, b):
    return a + b

@dispatch(float, float)
def add(a, b):
    return a + b

@dispatch(str, str)
def add(a, b):
    return a + " " + b

# Example usage
print(add(1, 2))           # 3 (integer addition)
print(add(1.5, 2.5))       # 4.0 (float addition)
print(add("Hello", "World"))  # "Hello World" (string concatenation)





_____________________________________________________________________________________________________________________


17. How Python memory management works ?
Answer =>

Python memory management is a process like how Python handles memory for your program. When you create something like a variable, list, or dictionary, Python allocate memory automatically. and When you’re done using it, Python deallocate memory automatically.


In python memory management python uses two tools - 
1. Reference count
2. Garbage collection



1. Reference Counting => 
-----------------------
Reference counting is a mechanism where every object in Python keeps track of the number of references pointing to it. When an object's reference count drops to zero, it means no part of the program is using that object, and Python automatically deallocates its memory.


Example of Referece Counting =>
-----------------------------
a = [1, 2, 3]  # List object created; reference count = 1
b = a           # Another reference to the same object; reference count = 2
c = a           # Another reference; reference count = 3

del b           # One reference removed; reference count = 2
del c           # Another reference removed; reference count = 1
del a           # Last reference removed; reference count = 0, object is deleted


You can also check the reference counting =>
------------------------------------------
import sys

a = [10,20,30,40]

print("The reference count of :- ",sys.getrefcount(a))

b = a

print("The reference count of :- ",sys.getrefcount(a))




2. Garbage Colletion =>
------------------------

Garbage Collection (GC) in Python is a mechanism for automatically identifying and reclaiming memory occupied by objects that are no longer in use, especially in situations where reference counting fails, such as with circular references.


Garbage Collection and Circular References:
------------------------------------------
Circular references occur when two or more objects reference each other, creating a cycle.

Example:
--------
class Node:
    def __init__(self, name):
        self.name = name
        self.ref = None

a = Node("A")
b = Node("B")
a.ref = b  # a references b
b.ref = a  # b references a
del a
del b



In this case, even though a and b are deleted, they still reference each other, so their reference counts do not drop to zero.
The garbage collector detects such cycles and removes them.





Why Is It Important?
_______________________
Good memory management ensures your program doesn’t crash or run out of memory.
Python handles most of it automatically, so you don’t have to worry about it (unlike languages like C or C++ where you have to manually free memory).





_____________________________________________________________________________________________________________________



18. What is the difference between append() and extend() methods in Python lists?

So Both append() and extend() are used to add element in a list but they work differently -


1. append:
----------
append adds one iteam to the end of the list.
If you pass a list to append(), it will add the entire list as a single element, not its items.


Example:
-------
my_list = [1, 2, 3]

# Append a single item
my_list.append(4)
print(my_list)  # Output: [1, 2, 3, 4]

# Append another list
my_list.append([5, 6])
print(my_list)  # Output: [1, 2, 3, 4, [5, 6]]





2. extend():
-------------
Adds all the elements of an iterable (like a list or tuple) to the end of the list.
It unpacks the items of the passed iterable and adds them individually.


Example:
--------

my_list = [1, 2, 3]

# Extend with another list
my_list.extend([4, 5, 6])
print(my_list)  # Output: [1, 2, 3, 4, 5, 6]

# Extend with a tuple
my_list.extend((7, 8))
print(my_list)  # Output: [1, 2, 3, 4, 5, 6, 7, 8]



_____________________________________________________________________________________________________________________




19. What is class method and instance method ?



Class Method:
-------------

A class method is a method that belongs to the class itself rather than a specific object (instance). It works with class-level data, which is shared among all objects of the class.

1. It is defined using the @classmethod decorator.
2. The first parameter is cls, which refers to the class.
3. Class methods are useful when you want to perform actions related to the class as a whole, such as working 
    with  class variables or creating alternative ways to construct objects.


Example of Class Method:
------------------------
class Car:
    manufacturer = "Toyota"  # Class-level data (shared by all cars)

    @classmethod
    def get_manufacturer(cls):
        return cls.manufacturer

# You can call a class method without creating an object
print(Car.get_manufacturer())  # Output: Toyota


get_manufacturer is a class method that retrieves the class attribute manufacturer.
It doesn't depend on any specific car object.

    

 

 What is an Instance Method?
 ---------------------------
An instance method is the most common type of method in a class. It works on specific objects (instances) of the class.

1. It is defined without any special decorator.
2. The first parameter is self, which refers to the specific object calling the method.
3. Instance methods can access and modify the attributes and behavior of the object they are called on.


Example of Instance Method:
--------------------------

class Car:
    def __init__(self, model):
        self.model = model  # Instance-level data (specific to an object)

    def get_model(self):
        return f"The car model is {self.model}"

# Creating an instance of Car
my_car = Car("Corolla")
print(my_car.get_model())  # Output: The car model is Corolla


get_model is an instance method that works with the attribute model specific to the my_car object.



_____________________________________________________________________________________________________________________

20. Dynamic Counting in Python?

dynamic counting in Python refers to the process of tracking or updating counts dynamically (on the fly) as your program runs. It involves using variables, data structures like dictionaries, or built-in tools to count occurrences, events, or other elements during runtime.

Example:
---------

Imagine you are processing a list of words and want to count how many times each word appears dynamically as you read the list.



words = ["apple", "banana", "apple", "orange", "banana", "apple"]
count = {}

for word in words:
    count[word] = count.get(word, 0) + 1

print(count)  # Output: {'apple': 3, 'banana': 2, 'orange': 1}




Example with collections.Counter
--------------------------------
A more Pythonic way to do dynamic counting is by using collections.Counter.


from collections import Counter
words = ["apple", "banana", "apple", "orange", "banana", "apple"]
count = Counter(words)
print(count)  # Output: Counter({'apple': 3, 'banana': 2, 'orange': 1})




____________________________________________________________________________________________________________________



21. What is the difference between yield and return in Python?

return:
------
return is a statement in Python that exits the function and sends a single value (or multiple values in a tuple) back to the caller. Once the return statement is executed, the function stops running immediately.

Work:
-----
It provides the final result of a function's execution.
After returning the value, the function cannot be resumed.

Example of return:
-----------------
def multiply(a, b):
    return a * b  # Sends the result back and stops the function

result = multiply(4, 5)
print(result)  # Output: 20





yield:
------
yield is a statement in Python that pauses the function and produces a value for the caller, but unlike return, it does not terminate the function. The function can be resumed later to continue execution from where it paused.

Work:
-----
It is used to create generators, which are special iterators that generate values one at a time.
When yield is used, the function becomes a generator function and returns an iterator.

Example of yield:
-----------------
def count_up_to(n):
    for i in range(1, n + 1):
        yield i  # Pauses after yielding each value

gen = count_up_to(3)
print(next(gen))  # Output: 1
print(next(gen))  # Output: 2
print(next(gen))  # Output: 3




Comparison of return and yield:
-------------------------------

Feature	                                return	                                yield

Purpose	                Returns a single result to the caller.	Produces a sequence of results over time.

Stops or Pauses	                 Stops the function entirely.	Pauses the function and remembers its state.

Use Case	         When a final output is needed.	                When you need to generate data lazily 
                                                                        or handle large datasets.

Creates	                    A value or a list of values.	A generator object (an iterable).




____________________________________________________________________________________________________________________

22. What is the difference between an iterator and an iterable in Python?


1. Iterable:
------------
An iterable is any object in Python that can be looped through (like a list, string, or tuple). It’s like a collection of items.

Examples of iterables:
--------------------
Lists: [1, 2, 3]
Strings: "hello"
Tuples: (4, 5, 6)

Sets, dictionaries, and more.
To make something iterable, it must have the special method __iter__(), which allows Python to start looping through it.


Example:
----------
my_list = [1, 2, 3]
for item in my_list:
    print(item)  # Output: 1, 2, 3







2. Iterator:
-------------
An iterator is an object that helps you go through an iterable one item at a time. It remembers where it left off, so you can fetch the next item with the next() function.

To be an iterator, the object must have:

__iter__() - to make it iterable.
__next__() - to fetch the next item.


Example:
--------

my_list = [1, 2, 3]
iterator = iter(my_list)  # Convert the list into an iterator.

print(next(iterator))  # Output: 1
print(next(iterator))  # Output: 2
print(next(iterator))  # Output: 3

Here, the iterator fetches one item at a time. Once it runs out of items, calling next() will raise a StopIteration error.






____________________________________________________________________________________________________________________


23. Difference between list , tuple and array

1. Defination:
--------------
Array:- A collection of elements of the same data type stored in a contiguous memory block.	
List :- A flexible collection of elements of any data type that can grow or shrink dynamically.	
Tuple :- An immutable collection of elements of any data type that cannot be changed after creation.



2. Mutability:
---------------
Array :-  Mutable (you can modify, add, or remove elements).	
List :- Mutable (you can modify, add, or remove elements).	
Tuple :- Immutable (once created, elements cannot be modified).


3. Size Modification:
---------------------
Array :- Can grow or shrink dynamically.	
List :- Can grow or shrink dynamically.	
Tuple :- Fixed size after creation (cannot add or remove elements).


4. Performance:
---------------
Array :- Faster for numerical computations because of fixed data types.	
List :- Slightly slower for numerical tasks but flexible for general usage.	
Tuple :- More memory-efficient and faster to access due to immutability.



5. Memory Usage:
-----------------
Array :- Efficient for large datasets of the same type.	
List:- Requires more memory for mixed-type storage.	
Tuple :- Most memory-efficient because of immutability.


6. Library Dependency:-
------------------------
Array :- Requires the array module or external libraries like NumPy for advanced operations.	
List :- Built-in Python data structure (no additional library required).	
Tuple :- Built-in Python data structure (no additional library required).


7. Use Case	:
-------------
Array :- Used for mathematical computations and large datasets where all items are of the same type.	
List :- Used for flexible data storage with mixed or dynamic content.	
Tuple :- Used for fixed, read-only data to ensure values do not accidentally change.


8. Creation Syntax:
-------------------
Array :- array('i', [1, 2, 3]) (for integers).	
List :- [1, 2, "hello", 4.5].	
Tuple :- (1, 2, "hello", 4.5).



____________________________________________________________________________________________________________________


24. What is pep8?

Yes, PEP 8 is a style guide for Python code that provides conventions for writing clean, readable, and consistent Python code. It is the official style guide for Python, and following its guidelines ensures that Python code is easy to read and maintain, both for individuals and teams.





____________________________________________________________________________________________________________________



25. what is __init__ ?

















____________________________________________________________________________________________________________________



26. What is closure in python ?


In simple words, a closure in Python is a function inside another function that remembers and can use variables from its outer function, even after the outer function has finished running.

Here's an easy way to think about it:

Imagine you have a box (the outer function) that contains something (a variable).
Inside that box, there's a smaller box (the inner function) that can look inside the bigger box and use what's in it.
Even after you close the bigger box (outer function), the smaller box (inner function) can still remember what was inside the bigger box and use it whenever you need it.




Example:
--------

def outer_function(outer_variable):
    def inner_function(inner_variable):
        return outer_variable + inner_variable
    return inner_function

# Create a closure
my_closure = outer_function(10)

# Call the closure with a new value
print(my_closure(5))  # Output: 15





In short, a closure allows an inner function to remember and use variables from its outer function even after the outer function has finished.


____________________________________________________________________________________________________________________


27. What is the interface in oops ?


In Object-Oriented Programming (OOP), an interface is a blueprint for a class. It defines a set of methods (but not their implementation) that a class must implement. An interface provides a way to enforce certain behaviors on the classes that implement it, ensuring consistency across different classes without dictating how the methods are executed.


Python doesn’t have built-in support for interfaces like Java or C#. Instead, Python uses abstract base classes (ABCs) to achieve similar functionality. You can create an interface in Python by using the abc module.


Example of an Interface in Python:
----------------------------------
from abc import ABC, abstractmethod

# Define an interface using an abstract base class
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass  # This method must be implemented by any subclass

    @abstractmethod
    def move(self):
        pass  # This method must also be implemented

# Implementing the interface
class Dog(Animal):
    def speak(self):
        return "Bark"

    def move(self):
        return "Runs"

class Bird(Animal):
    def speak(self):
        return "Chirp"

    def move(self):
        return "Flies"

# Using the classes
dog = Dog()
bird = Bird()

print(dog.speak())  # Output: Bark
print(bird.move())  # Output: Flies

____________________________________________________________________________________________________________________

28. What is a context manager in Python, and how is it used?







____________________________________________________________________________________________________________________

29. How do you create a custom context manager in Python?







____________________________________________________________________________________________________________________

30. What is the hashing technique in Python?

The hashing technique in Python is a method of converting data (like strings, numbers, or objects) into a fixed-size integer value, called a hash value or hash code. Hashing is primarily used in data structures like hash tables and sets for fast data access, and for verifying data integrity in cryptographic operations.

Key Points About Hashing:
-------------------------

Hash Function:
-------------
A hash function takes an input (data) and returns a fixed-size hash value.
In Python, the hash() function generates the hash value of an object.

Purpose:
-------
Efficiently store and retrieve data in hash-based data structures like dictionaries and sets.
Ensure data integrity (e.g., in cryptographic applications).

Deterministic:
-------------
For the same input, a hash function always produces the same output during a single program execution.

Immutability:
-------------
Only immutable objects (like strings, numbers, and tuples) can be hashed in Python.




Built-In Hashing in Python:
---------------------------
Python provides a built-in hash() function to compute hash values for hashable objects.

Example:
--------
# Using hash() function
value = "hello"
hash_value = hash(value)
print(hash_value)  # Output: An integer (hash value)







____________________________________________________________________________________________________________________

31. How can you determine which task has completed in a multithreaded environment?








____________________________________________________________________________________________________________________

32. what is class method , static method , and instance method?


1. Instance Method:
-------------------

Definition: A method that belongs to an object (instance) and can use or change the object’s data.

How to identify: It always has self as the first parameter.

Example:
---------
class Dog:
    def __init__(self, name):  # This runs when we create an object
        self.name = name  # Store the name of the dog

    def greet(self):  # Instance method
        return f"Hello, my name is {self.name}"  # Uses object data

dog = Dog("Buddy")  # Create an object
print(dog.greet())  # Output: Hello, my name is Buddy





2. Class Method:
---------------

Definition: A method that belongs to the class, not any specific object. It works on the class itself and uses cls as the first parameter.

How to identify: Decorated with @classmethod.


Example:
---------
class Dog:
    species = "Canine"  # Shared by all dogs (class data)

    @classmethod
    def show_species(cls):  # Class method
        return f"All dogs are {cls.species}"

print(Dog.show_species())  # Output: All dogs are Canine


3. Static Method:
----------------

Definition: A method that doesn’t use self (object) or cls (class). It’s just a regular function that happens to be inside the class.

How to identify: Decorated with @staticmethod.

Example:
-------
class Dog:
    @staticmethod
    def info():  # Static method
        return "Dogs are loyal animals."

print(Dog.info())  # Output: Dogs are loyal animals.


____________________________________________________________________________________________________________________

34.  What is the difference between synchronous and asynchronous programming languages?



Synchronous Programming:
------------------------
In synchronous programming, tasks are executed one after another. The program waits for the current task to finish before starting the next one.

If one task takes a long time (e.g., downloading a file), everything else has to wait.

Example:
-------
def task1():
    print("Task 1 started")
    print("Task 1 completed")

def task2():
    print("Task 2 started")
    print("Task 2 completed")

task1()
task2()





Asynchronous Programming:
-------------------------

In asynchronous programming, tasks can run independently. The program doesn’t wait for one task to finish; it starts other tasks while waiting for the result of the first one.

Allows other tasks to continue running instead of waiting, making it faster for some scenarios (like network requests).


Example:
--------

import asyncio

async def task1():
    print("Task 1 started")
    await asyncio.sleep(2)  # Simulates waiting (e.g., for a file download)
    print("Task 1 completed")

async def task2():
    print("Task 2 started")
    await asyncio.sleep(1)
    print("Task 2 completed")

async def main():
    await asyncio.gather(task1(), task2())  # Run tasks concurrently

asyncio.run(main())



Output:
--------
Task 1 started  
Task 2 started  
Task 2 completed  
Task 1 completed  



Notice how Task 2 completes while Task 1 is still running.






Main Differences:
-----------------

Feature	                            Synchronous	                                    Asynchronous

Execution Order	                Tasks run one after another.	            Tasks can run concurrently.

Waiting	                        Program waits for each task.	        Other tasks continue while waiting.

Speed	                        Slower for tasks needing waits.	        Faster in scenarios like I/O operations.

Example Scenario            	Reading files line-by-line.	                Handling multiple API requests.





____________________________________________________________________________________________________________________


36. What is the heap memory and stack memory?



1. What is Stack Memory?
------------------------
1. Stack memory is used for temporary storage of data, like variables inside a function.
2. When a function runs, it uses stack memory to keep track of its variables.
3. Once the function is done, the stack clears that memory automatically.


Example:
--------
def add_numbers(a, b):
    result = a + b  # `a`, `b`, and `result` are in stack memory
    return result

add_numbers(3, 4)  # Stack memory is cleared when this function finishes




2. What is Heap Memory?
-------------------------
1. Heap memory is used to store big data or things that need to last longer, like objects, lists, or dictionaries.
2. Unlike stack memory, heap memory doesn’t clear automatically — Python’s garbage collector manages it.
3. It’s slower than stack memory but much bigger in size.

Example:
--------
data = [1, 2, 3, 4]  # This list is stored in heap memory
print(data)






Feature	                               Stack Memory	                                Heap Memory
--------                               ------------                                ------------
What it stores	          Temporary data like variables in functions.	 Long-lasting data like objects and lists.

Speed	                            Very fast to access.	                    Slower to access.

Size	                            Small and limited.	                    Large and can grow as needed.

Management	                Cleared automatically after function ends.	Managed by Python’s garbage collector.

Analogy	                            Like a stack of plates.	                    Like a big storage room.


____________________________________________________________________________________________________________________






____________________________________________________________________________________________________________________

38. Difference between cls and self in class and instance methods?


What is self:
--------------

self refers to the current instance of the class.
It is used in instance methods to access or modify the properties (attributes) and methods of that specific object.

Example:
--------
class Dog:
    def __init__(self, name):  # Instance method
        self.name = name  # `self.name` refers to the current instance's name
    
    def bark(self):
        print(f"{self.name} says Woof!")  # `self.name` accesses the instance's name

dog1 = Dog("Buddy")
dog1.bark()  # Output: Buddy says Woof!




What is cls:
------------
cls refers to the class itself, not any specific instance.
It is used in class methods to access or modify the properties (attributes) of the entire class, like shared variables or class-level attributes.


Example:
--------
class Dog:
    species = "Canine"  # Class-level attribute shared by all instances
    
    @classmethod
    def set_species(cls, new_species):  # Class method
        cls.species = new_species  # `cls.species` modifies the class-level attribute

print(Dog.species)  # Output: Canine
Dog.set_species("Wolf")  # Change species for the entire class
print(Dog.species)  # Output: Wolf


____________________________________________________________________________________________________________________

39. Method Resolution Order (MRO)?

MRO (Method Resolution Order) is the order in which Python looks for a method or attribute in a class and its parent classes when you call it. It’s like a roadmap that tells Python where to search first, second, and so on.


1. MRO in Single Inheritance:
-----------------------------
If a class has only one parent, Python will:

1. Check the method in the current class.
2. If not found, check the parent class.
3. Finally, check the base class object (all classes in Python inherit from this).


Example:
--------
class Parent:
    def show(self):
        print("This is Parent")

class Child(Parent):
    pass

obj = Child()
obj.show()  # Output: This is Parent

Here, Child doesn’t have a show() method, so Python looks in Parent.






Example 2: Multiple Inheritance:
-------------------------------
class A:
    def show(self):
        print("Class A")

class B:
    def show(self):
        print("Class B")

class C(A, B):
    pass

obj = C()
obj.show()
# Output: Class A


How MRO Works Here:

Python first checks C.
Then it checks A (leftmost parent).
Finally, it checks B.









Example 3: Diamond Problem:
----------------------------
The diamond problem occurs in multiple inheritance when a class inherits from two classes, which both inherit from a common base class.


class A:
    def show(self):
        print("Class A")

class B(A):
    def show(self):
        print("Class B")

class C(A):
    pass

class D(B, C):  # D inherits from B and C
    pass

obj = D()
obj.show()

# Output: Class B



How MRO Solves This:

Python uses MRO to ensure each class is visited only once.
MRO for D is: D → B → C → A → object.





How to Check MRO:
-----------------
You can view the MRO of any class using:

The mro() method:
----------------
print(D.mro())
# Output: [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

The help() function:
--------------------
help(D)





____________________________________________________________________________________________________________________

